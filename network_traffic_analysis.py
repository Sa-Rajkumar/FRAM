# -*- coding: utf-8 -*-
"""Network_Traffic_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rhZl3gwm9Qa8sglBHnU-yyWPvokYot5_
"""

# prompt: read excel file using pandas library into tabular format

import pandas as pd

# Read the Excel file
df = pd.read_excel('ROS.xlsx')

# Print the DataFrame
print(df)

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_excel('ROS.xlsx')


df['Time'] = pd.to_datetime(df['Time'])
df = df.set_index('Time')

df['Count'] = 1

df = df.resample('1s').sum()

df.plot(y='Count')
plt.xlabel('Time')
plt.ylabel('Number of Packets')
plt.title('Number of Packets per Second')
plt.show()

# prompt: whats the average and standard deviation

avg = df['Count'].mean()
std_dev = df['Count'].std()

print(f"Average number of packets per second: {avg}")
print(f"Standard deviation of number of packets per second: {std_dev}")

# prompt: show the time of the packets that excede the average+standard deviation

import pandas as pd
import matplotlib.pyplot as plt

# Read the Excel file
df = pd.read_excel('ROS.xlsx')




df['Time'] = pd.to_datetime(df['Time'])
df = df.set_index('Time')

df['Count'] = 1

df = df.resample('1s').sum()

df.plot(y='Count')
plt.xlabel('Time')
plt.ylabel('Number of Packets')
plt.title('Number of Packets per Second')
plt.show()

avg = df['Count'].mean()
std_dev = df['Count'].std()

print(f"Average number of packets per second: {avg}")
print(f"Standard deviation of number of packets per second: {std_dev}")

# Find the time of packets that exceed the average + standard deviation
exceed_times = df[df['Count'] > (avg + std_dev)].index.tolist()

# Print the time of the packets
print("Time of packets that exceed the average + standard deviation:")
for time in exceed_times:
  print(time)

# prompt: find the number of counts corresponding to the each exceeding time

exceeding_counts = df.loc[exceed_times, 'Count'].tolist()

# Print the number of counts corresponding to each exceeding time
print("Number of counts corresponding to each exceeding time:")
for time, count in zip(exceed_times, exceeding_counts):
  print(f"Time: {time}, Count: {count}")

# prompt: display the corresponding time1 data to the above exceeded time data

# Extract the corresponding time1 data for the exceeding time data
time1_exceeding_data = []
for time in exceed_times:
  # Find the index of the exceeding time in the original DataFrame
  index = df.index.get_loc(time)
  # Extract the corresponding time1 data
  time1_exceeding_data.append(df.iloc[index]['Time1'])

# Print the corresponding time1 data
print("Corresponding time1 data for the exceeded time data:")
for time, time1, count in zip(exceed_times, time1_exceeding_data, exceeding_counts):
  print(f"Time: {time}, Time1: {round(time1/count)}")

# prompt: make a list of the above Time1 output and print the list as [37,97,127....517,577]

# Extract the corresponding time1 data for the exceeding time data
time1_exceeding_data = []
for time in exceed_times:
  # Find the index of the exceeding time in the original DataFrame
  index = df.index.get_loc(time)
  # Extract the corresponding time1 data
  time1_exceeding_data.append(df.iloc[index]['Time1'])

# Calculate the rounded time1 values
Time1 = [round(time1/count) for time1, count in zip(time1_exceeding_data, exceeding_counts)]

# Print the list as [37,97,127....517,577]
print(Time1)

# prompt: iterate every row of the dataframe df
import pandas as pd

# Read the Excel file
df = pd.read_excel('ROS.xlsx')

# Print the DataFrame
print(df)

# prompt: code to search for Time1=37 and create a dataframe to store all the data

# Filter the DataFrame to only include rows where Time1 is equal to 37
df_time1_37 = df[df['Time1'] == 37]

# Create a new DataFrame to store the filtered data
df_filtered = pd.DataFrame(df_time1_37)

# Print the filtered DataFrame
print(df_filtered)

# prompt: search for each item in the list time1

for time in Time1:

  print(f"Searching for time: {time}")
  print(df[df['Time1'] == time])

for time in Time1:
  time_37_df = df[df['Time1'] == time]

# Group the filtered DataFrame by 'Protocol' and count occurrences
  protocol_counts = time_37_df.groupby('Protocol')['Protocol'].count()

# Print the results
  print(f"Different types of protocol for time {time} and their occurrences:")
  print(protocol_counts)

for time in Time1:
  time_37_df = df[df['Time1'] == time]

  # Group the filtered DataFrame by 'Protocol' and count occurrences
  protocol_counts = time_37_df.groupby('Protocol')['Protocol'].count()

  # Find the protocol with the highest count
  most_frequent_protocol = protocol_counts.idxmax()
  count = protocol_counts.max()

  print(f"For time {time}, the most frequent protocol is {most_frequent_protocol} with {count} occurrences.")

for time in Time1:
  time_df = df[df['Time1'] == time]

  # Group the filtered DataFrame by 'Protocol' and count occurrences
  protocol_counts = time_df.groupby('Protocol')['Protocol'].count()

  # Sort the protocol counts in descending order
  sorted_counts = protocol_counts.sort_values(ascending=False)

  # Check if there are at least two protocols
  if len(sorted_counts) >= 2:
    # Get the most and second most frequent protocols
    most_frequent_protocol = sorted_counts.index[0]
    second_most_frequent_protocol = sorted_counts.index[1]

    # Get the counts for the most and second most frequent protocols
    most_frequent_count = sorted_counts.iloc[0]
    second_most_frequent_count = sorted_counts.iloc[1]

    print(f"For time {time}:")
    print(f"  Most frequent protocol: {most_frequent_protocol} ({most_frequent_count} times)")
    print(f"  Second most frequent protocol: {second_most_frequent_protocol} ({second_most_frequent_count} times)")
  else:
    print(f"For time {time}, there are less than two protocols.")

broadcast_df = df[df['Destination'] == 'Broadcast']

# Print the filtered DataFrame
print(broadcast_df)

# Group the broadcast DataFrame by 'Source' and count occurrences
source_counts = broadcast_df.groupby('Source')['Source'].count()

# Sort the source counts in descending order
sorted_counts = source_counts.sort_values(ascending=False)

# Check if there are at least two sources
if len(sorted_counts) >= 2:
  # Get the most and second most frequent sources
  most_frequent_source = sorted_counts.index[0]
  second_most_frequent_source = sorted_counts.index[1]

  # Get the counts for the most and second most frequent sources
  most_frequent_count = sorted_counts.iloc[0]
  second_most_frequent_count = sorted_counts.iloc[1]

  print("In broadcast DataFrame:")
  print(f"  Most frequent source: {most_frequent_source} ({most_frequent_count} times)")
  print(f"  Second most frequent source: {second_most_frequent_source} ({second_most_frequent_count} times)")
else:
  print("In broadcast DataFrame, there are less than two sources.")

# prompt: create a dataframe for destination equal to vrrp.mcast.net

vrrp_df = df[df['Destination'] == 'vrrp.mcast.net']

# Print the filtered DataFrame
print(vrrp_df)

# Group the vrrp DataFrame by 'Source' and count occurrences
source_counts = vrrp_df.groupby('Source')['Source'].count()

# Sort the source counts in descending order
sorted_counts = source_counts.sort_values(ascending=False)

# Check if there are at least two sources
if len(sorted_counts) >= 2:
  # Get the most and second most frequent sources
  most_frequent_source = sorted_counts.index[0]
  second_most_frequent_source = sorted_counts.index[1]

  # Get the counts for the most and second most frequent sources
  most_frequent_count = sorted_counts.iloc[0]
  second_most_frequent_count = sorted_counts.iloc[1]

  print("In VRRP DataFrame:")
  print(f"  Most frequent source: {most_frequent_source} ({most_frequent_count} times)")
  print(f"  Second most frequent source: {second_most_frequent_source} ({second_most_frequent_count} times)")
else:
  print("In VRRP DataFrame, there are less than two sources.")